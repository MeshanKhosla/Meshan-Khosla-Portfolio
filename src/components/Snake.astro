---
// Snake.astro - A clean, minimal snake game that respects the theme
---

<div class="snake-game-container relative">
  <div class="relative rounded-lg overflow-hidden border border-cream-300 dark:border-ink-lighter">
    <canvas
      id="snake-canvas"
      class="w-full bg-cream-50 dark:bg-ink-light block"
      style="aspect-ratio: 2/1;"
    ></canvas>
    
    <!-- Overlay for game states -->
    <div
      id="game-overlay"
      class="absolute inset-0 flex flex-col items-center justify-center 
             bg-cream-50/90 dark:bg-ink-light/90 backdrop-blur-sm"
    >
      <p class="text-charcoal-muted dark:text-sand-muted text-sm mb-2 hidden lg:block">
        Use arrow keys or WASD
      </p>
      <p class="text-charcoal-muted dark:text-sand-muted text-sm mb-2 lg:hidden">
        Swipe or use controls below
      </p>
      <p class="text-charcoal dark:text-sand font-medium hidden lg:block">
        Press any key to start
      </p>
      <p class="text-charcoal dark:text-sand font-medium lg:hidden">
        Tap to start
      </p>
    </div>
  </div>
  
  <!-- Score -->
  <div class="flex items-center justify-between mt-3 px-1">
    <span class="text-sm text-charcoal-muted dark:text-sand-muted">Score</span>
    <span id="snake-score" class="text-sm font-medium text-charcoal dark:text-sand tabular-nums">0</span>
  </div>
  
  <!-- Mobile Controls (visible on touch devices) -->
  <div id="mobile-controls" class="mt-4 flex flex-col items-center gap-1 lg:hidden">
    <button
      id="btn-up"
      type="button"
      class="w-12 h-12 rounded-lg bg-cream-200 dark:bg-ink-lighter 
             flex items-center justify-center active:bg-cream-300 dark:active:bg-ink
             text-charcoal dark:text-sand transition-colors touch-manipulation"
      aria-label="Move up"
    >
      <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />
      </svg>
    </button>
    <div class="flex gap-1">
      <button
        id="btn-left"
        type="button"
        class="w-12 h-12 rounded-lg bg-cream-200 dark:bg-ink-lighter 
               flex items-center justify-center active:bg-cream-300 dark:active:bg-ink
               text-charcoal dark:text-sand transition-colors touch-manipulation"
        aria-label="Move left"
      >
        <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
        </svg>
      </button>
      <button
        id="btn-start"
        type="button"
        class="w-12 h-12 rounded-lg bg-accent/20 dark:bg-accent-light/20
               flex items-center justify-center active:bg-accent/30 dark:active:bg-accent-light/30
               text-accent dark:text-accent-light transition-colors touch-manipulation"
        aria-label="Start/Restart"
      >
        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
          <path d="M8 5v14l11-7z" />
        </svg>
      </button>
      <button
        id="btn-right"
        type="button"
        class="w-12 h-12 rounded-lg bg-cream-200 dark:bg-ink-lighter 
               flex items-center justify-center active:bg-cream-300 dark:active:bg-ink
               text-charcoal dark:text-sand transition-colors touch-manipulation"
        aria-label="Move right"
      >
        <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
        </svg>
      </button>
    </div>
    <button
      id="btn-down"
      type="button"
      class="w-12 h-12 rounded-lg bg-cream-200 dark:bg-ink-lighter 
             flex items-center justify-center active:bg-cream-300 dark:active:bg-ink
             text-charcoal dark:text-sand transition-colors touch-manipulation"
      aria-label="Move down"
    >
      <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
      </svg>
    </button>
  </div>
</div>

<script>
  interface GameState {
    snake: { x: number; y: number }[];
    food: { x: number; y: number };
    direction: { x: number; y: number };
    nextDirection: { x: number; y: number };
    score: number;
    isRunning: boolean;
    gameOver: boolean;
  }

  function initSnakeGame() {
    const canvas = document.getElementById('snake-canvas') as HTMLCanvasElement;
    const overlay = document.getElementById('game-overlay') as HTMLDivElement;
    const scoreEl = document.getElementById('snake-score') as HTMLSpanElement;
    
    if (!canvas || !overlay || !scoreEl) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Configuration
    const CELL_SIZE = 12;
    const GAME_SPEED = 100; // ms per frame

    // Resize canvas to fit container while maintaining cell alignment
    const resizeCanvas = () => {
      const container = canvas.parentElement;
      if (!container) return;
      
      const width = container.clientWidth;
      const height = Math.floor(width / 2);
      
      canvas.width = Math.floor(width / CELL_SIZE) * CELL_SIZE;
      canvas.height = Math.floor(height / CELL_SIZE) * CELL_SIZE;
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Get theme-aware colors
    const getColors = () => {
      const isDark = document.documentElement.classList.contains('dark');
      return {
        snake: isDark ? '#E8E4DC' : '#1A1A1A',
        snakeHead: isDark ? '#3B7EA1' : '#003262',
        food: isDark ? '#3B7EA1' : '#003262',
        grid: isDark ? 'rgba(232, 228, 220, 0.05)' : 'rgba(26, 26, 26, 0.05)',
      };
    };

    // Game state
    let state: GameState = createInitialState();
    let gameLoop: number | null = null;
    let lastUpdate = 0;

    function createInitialState(): GameState {
      const cols = Math.floor(canvas.width / CELL_SIZE);
      const rows = Math.floor(canvas.height / CELL_SIZE);
      
      return {
        snake: [
          { x: Math.floor(cols / 4), y: Math.floor(rows / 2) },
        ],
        food: spawnFood(cols, rows, []),
        direction: { x: 1, y: 0 },
        nextDirection: { x: 1, y: 0 },
        score: 0,
        isRunning: false,
        gameOver: false,
      };
    }

    function spawnFood(cols: number, rows: number, snake: { x: number; y: number }[]): { x: number; y: number } {
      let food: { x: number; y: number };
      do {
        food = {
          x: Math.floor(Math.random() * cols),
          y: Math.floor(Math.random() * rows),
        };
      } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
      return food;
    }

    function update() {
      if (!state.isRunning || state.gameOver) return;

      const cols = Math.floor(canvas.width / CELL_SIZE);
      const rows = Math.floor(canvas.height / CELL_SIZE);

      // Apply direction change
      state.direction = state.nextDirection;

      // Calculate new head position
      const head = state.snake[0];
      const newHead = {
        x: (head.x + state.direction.x + cols) % cols,
        y: (head.y + state.direction.y + rows) % rows,
      };

      // Check self collision
      if (state.snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {
        state.gameOver = true;
        state.isRunning = false;
        overlay.innerHTML = `
          <p class="text-charcoal dark:text-sand font-medium mb-2">Game Over!</p>
          <p class="text-charcoal-muted dark:text-sand-muted text-sm">Score: ${state.score}</p>
          <p class="text-charcoal-muted dark:text-sand-muted text-sm mt-2">Press any key to restart</p>
        `;
        overlay.classList.remove('hidden');
        return;
      }

      // Move snake
      state.snake.unshift(newHead);

      // Check food collision
      if (newHead.x === state.food.x && newHead.y === state.food.y) {
        state.score += 1;
        scoreEl.textContent = state.score.toString();
        state.food = spawnFood(cols, rows, state.snake);
      } else {
        state.snake.pop();
      }
    }

    function draw() {
      const colors = getColors();
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw subtle grid
      ctx.strokeStyle = colors.grid;
      ctx.lineWidth = 1;
      for (let x = 0; x <= canvas.width; x += CELL_SIZE) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += CELL_SIZE) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw food with glow
      ctx.fillStyle = colors.food;
      ctx.shadowColor = colors.food;
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.roundRect(
        state.food.x * CELL_SIZE + 2,
        state.food.y * CELL_SIZE + 2,
        CELL_SIZE - 4,
        CELL_SIZE - 4,
        3
      );
      ctx.fill();
      ctx.shadowBlur = 0;

      // Draw snake
      state.snake.forEach((segment, index) => {
        ctx.fillStyle = index === 0 ? colors.snakeHead : colors.snake;
        ctx.beginPath();
        ctx.roundRect(
          segment.x * CELL_SIZE + 1,
          segment.y * CELL_SIZE + 1,
          CELL_SIZE - 2,
          CELL_SIZE - 2,
          index === 0 ? 4 : 2
        );
        ctx.fill();
      });
    }

    function gameStep(timestamp: number) {
      if (!state.isRunning) return;

      if (timestamp - lastUpdate >= GAME_SPEED) {
        update();
        lastUpdate = timestamp;
      }
      
      draw();
      gameLoop = requestAnimationFrame(gameStep);
    }

    function startGame() {
      state = createInitialState();
      scoreEl.textContent = '0';
      overlay.classList.add('hidden');
      state.isRunning = true;
      lastUpdate = performance.now();
      gameLoop = requestAnimationFrame(gameStep);
    }

    function handleKeyDown(e: KeyboardEvent) {
      // Start or restart game on any key
      if (!state.isRunning || state.gameOver) {
        startGame();
        return;
      }

      const key = e.key.toLowerCase();
      
      // Prevent reversing direction
      switch (key) {
        case 'arrowup':
        case 'w':
          if (state.direction.y !== 1) {
            state.nextDirection = { x: 0, y: -1 };
          }
          e.preventDefault();
          break;
        case 'arrowdown':
        case 's':
          if (state.direction.y !== -1) {
            state.nextDirection = { x: 0, y: 1 };
          }
          e.preventDefault();
          break;
        case 'arrowleft':
        case 'a':
          if (state.direction.x !== 1) {
            state.nextDirection = { x: -1, y: 0 };
          }
          e.preventDefault();
          break;
        case 'arrowright':
        case 'd':
          if (state.direction.x !== -1) {
            state.nextDirection = { x: 1, y: 0 };
          }
          e.preventDefault();
          break;
      }
    }

    // Pause when window loses focus
    function handleVisibilityChange() {
      if (document.hidden && state.isRunning && !state.gameOver) {
        state.isRunning = false;
        if (gameLoop) {
          cancelAnimationFrame(gameLoop);
          gameLoop = null;
        }
        overlay.innerHTML = `
          <p class="text-charcoal dark:text-sand font-medium">Paused</p>
          <p class="text-charcoal-muted dark:text-sand-muted text-sm mt-2">Press any key to continue</p>
        `;
        overlay.classList.remove('hidden');
      }
    }

    // Mobile control handlers
    function changeDirection(dir: 'up' | 'down' | 'left' | 'right') {
      // Start game if not running
      if (!state.isRunning || state.gameOver) {
        startGame();
        return;
      }

      switch (dir) {
        case 'up':
          if (state.direction.y !== 1) {
            state.nextDirection = { x: 0, y: -1 };
          }
          break;
        case 'down':
          if (state.direction.y !== -1) {
            state.nextDirection = { x: 0, y: 1 };
          }
          break;
        case 'left':
          if (state.direction.x !== 1) {
            state.nextDirection = { x: -1, y: 0 };
          }
          break;
        case 'right':
          if (state.direction.x !== -1) {
            state.nextDirection = { x: 1, y: 0 };
          }
          break;
      }
    }

    // Mobile button controls
    const btnUp = document.getElementById('btn-up');
    const btnDown = document.getElementById('btn-down');
    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const btnStart = document.getElementById('btn-start');

    btnUp?.addEventListener('click', () => changeDirection('up'));
    btnDown?.addEventListener('click', () => changeDirection('down'));
    btnLeft?.addEventListener('click', () => changeDirection('left'));
    btnRight?.addEventListener('click', () => changeDirection('right'));
    btnStart?.addEventListener('click', () => {
      if (!state.isRunning || state.gameOver) {
        startGame();
      }
    });

    // Swipe gesture support
    let touchStartX = 0;
    let touchStartY = 0;
    const SWIPE_THRESHOLD = 30;

    function handleTouchStart(e: TouchEvent) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }

    function handleTouchEnd(e: TouchEvent) {
      if (!e.changedTouches.length) return;
      
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      
      // Determine swipe direction based on larger delta
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Horizontal swipe
        if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
          changeDirection(deltaX > 0 ? 'right' : 'left');
        }
      } else {
        // Vertical swipe
        if (Math.abs(deltaY) > SWIPE_THRESHOLD) {
          changeDirection(deltaY > 0 ? 'down' : 'up');
        }
      }
    }

    canvas.addEventListener('touchstart', handleTouchStart, { passive: true });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: true });

    // Event listeners
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('visibilitychange', handleVisibilityChange);

    // Initial draw
    draw();

    // Cleanup function
    const cleanup = () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('resize', resizeCanvas);
      canvas.removeEventListener('touchstart', handleTouchStart);
      canvas.removeEventListener('touchend', handleTouchEnd);
      if (gameLoop) {
        cancelAnimationFrame(gameLoop);
      }
    };

  }

  // Initialize on load
  initSnakeGame();

</script>
